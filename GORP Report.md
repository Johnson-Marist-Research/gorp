# GORP Summer Research Project
### Presented by Cayleigh Goberman, Melissa Chodziutko, and Matthew Johnson

## Introduction
Goal-Oriented Response Planning (GORP) acts as an agent to protect against cyber threats. It utilizes Goal-Oriented Action Planning (GOAP), an algorithm often employed when programming non-player characters in video games, in order to create a variety of plans that can change depending on the requirements of the system. GOAP features a pre-set list of actions, but the order in which the actions are performed is determined by a planner algorithm. As such, this allows the program to display emergent behavior; for example, if a specific threat makes itself known, the program will prioritize the threat over, say, scanning files. The goal of this project is to adapt GORP into a cybersecurity setting in order to create an effective defense against cyber criminals, one which is constantly changing and thus hard for said criminals to predict. This should lead to a decreased likelihood that cyber criminals will be able to steal sensitive data from the targeted system.

## Problem that Research Addresses
GORP employs GOAP strategies in order to execute dynamic plans when defending a device from cyber attacks. Numerous cyber defense programs run sequentially through a list of actions that they then perform to minimize a threat. GOAP features a set of pre-defined actions, but the sequence of actions is not predetermined and is instead determined by a planner algorithm. As such, this encourages emergent behavior, as the program executes a sequence of actions that the developer did not directly program. This allows GORP to create and undertake a variety of plans and actions in order to dynamically respond to a variety of threats.

## Objectives
- Successfully protect a device from cybersecurity threats
- Improve the ease with which users can implement cybersecurity actions
- Perform defensive cybersecurity actions to mitigate the risk of a cyber attack on the device

## Test Scenarios
GORP is currently able to respond to two different scenarios. With the streamlining of the planning process, further situations should be able to be added fairly easily as long as the coded response is sound. The two situations that GORP currently responds to are as follows:


**DOS Attack**

A denial of service (DOS) attack occurs when a malicious actor targets a specific server, service, or network. The actor floods the network with traffic from various sources, which in turn overwhelms the network, prevents it from performing critical services, and renders it unavailable to normal users.

GORP attempts to address this form of attack by periodically scanning the incoming traffic on various ports. The program's test case creates ten different "ports", each with a random traffic value assigned to them. The program then takes a static "average" traffic value and compares it to each port. If a port's traffic value is more than 50% above the average, it is marked as having an unusual amount of traffic. GORP will begin to make a plan. Eventually, it will get to the set of variables that indicates that there may be a potential DOS attack occurring. GORP eventually concludes that it will have to shut down the affected port. In our test case, this occurs during the execution step, where the program resets the port's traffic value to zero. 

Since this is a simple test case, it would obviously have to be modified for future applications. Most devices have far more than ten ports, and scanning all of them could be time-consuming and resource heavy. As such, it may be advantageous to focus on the ports that deal with the most amount of traffic, with all other ports only being scanned occassionally. Additionally, each port will need an individual average traffic value assigned to them. This value can be generated after regularly taking samples of the traffic amount over the course of an extended test period. The amount of expected traffic on ports can vary widely; one port could rarely be used, resulting in a low average traffic value, whereas another could be used regularly by multiple sources. As such, unlike in the test case, the average traffic value must be changeable across various ports instead of one static value applied to all ports, as is the case in the origianl teat scenario. If the user does not want to block all traffic to a port, we could instead set up firewalls that filter specific traffic. This would hopefully lower the amount of traffic traveling through the port while also allowing legitimate activity to continue.


**ARP Spoofing**

ARP spoofing occurs when an agent sends malicious Address Resolution Protocol (ARP) messages to a network. These messages aim to trick the device into associating the attacker's Media Acces Control (MAC) address with the legitimate Internet Protocol (IP) address of a host. This causes any traffic meant for that IP address to be sent to the attacker instead. 

In Linux, the ARP table, or the table that keeps track of all IP addresses and their associated MAC addresses, can be accessed via the command */proc/net/arp*. This is a system file that can be read like a normal text file. As such, GORP's test scenario creates a fake ARP table file. It is formatted identically to the real ARP table, but we can modify it to add and remove different entries. 

GORP's sensors start by scanning the ARP table and making a list of all MAC addresses. This list also includes a count of how many times the MAC address appeared. If a MAC address appears more than once, the program sets a few variables to indicate that there may be something wrong in the ARP table. Once GORP's planning algorithm decides to address this inconsistency, it proceeds to execute the solution code. In this test scenario, each entry with the repeating MAC address is removed, leaving only those with a MAC address that had originally occurred once. This is meant to simulate the program removing and blocking the entries from a real ARP table. 

If we were to apply this outside of the test case, it might be useful to keep a list of blocked MAC and IP addresses. This would allow us to quickly reinstate a legitimate address that might have been blocked accidentally.

## Challenges
Certain aspects of GORP took longer than anticipated to complete. For example, the planner portion of the algorithm proved to be severely bug-riddent due to its inherent complexity; in particular, there was a specific bug where it could not identify unhelpful responses, leading it to add unneeded options to the possible paths. This created a near-infinite loop of the program searching for a path that it would never locate. As such, it took a bit of time to get the planner to function well. Additionally, the main programmer on this project was familiar with C++, but had yet to delve too deeply into it. The resulting learning curve slowed down progress ever so slightly, although they were quick to learn from their mistakes. Furthermore, another challenge that occurred during this project was related to the architectural complexities of the GORP design. The various components of the algorithm were deeply interconnected; as such, they needed to be functioning perfectly in order for the correct solution to be located. Time, effort, and attention to detail needed to be applied to the program so as to facilitate an efficient system.

Perhaps the most notable challenge we encountered also happened to be one of the most interesting aspects of our work. As we developed GORP, we encountered a variety of new questions and considerations that we could have never anticipated upon starting the project. For example, as we worked on the port test case, we realized that a true production-ready version of GORP would have to account for the individual traffic on all ports of the device. This traffic varies according to the port, with some having higher averages than others. Additionally, GORP would have to have an efficient way to scan these ports so as to not take up too much time or processing power. These considerations, while unanticipated and sometimes time-consuming, proved to be interesting challenges and ideas that we were able to either implement successfully or note down for future development. 

## Conclusion
GORP is currently in a good position. The majority of the original architectural design has been added and the basic framework is established. The main planning component of the system, the planner, is fully implemented and has been thoroughly tested. It is able to successfully find a solution for the test cases we have created, thus allowing the remaining parts of the algorithm to execute a solution. The two test cases in question function well and provide decent scenarios for GORP to analyze. Over the course of the past two months, we have successfully built the bedrock of this complex algorithm. As such, all that is left to do is to improve upon it.

## Future Considerations
While GORP's original architectural design has been successfully implemented, there are still numerous components that can be added or improved upon. In particular, the blackboard and subsystem components remain very simple compared to other facets like the planner, agent, and sensors. They could benefit from further development, especially if we wish to revisit the knowledge representation as well. While the knowledge and interfaces between the componets are effective, they remain rudimentary and could potentially cause problems later on. Knowledge is spread out over a few different maps, such as the ports and macAddresses maps, and information exchange between functions and classes usually takes the form of function arguments and public variables. It functions, but is not very elegant. 

Overall, if we were to take this concept further, we would aim to take this proof-of-concept and develop it into a production-ready agent. This would require much more testing and development in various sandbox environments, but the final product would be able to efficiently address far more malicious attacks than the two we have currently accounted for. 
